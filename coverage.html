
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/cmd/cli/main.go (0.0%)</option>
				
				<option value="file1">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/config/http/echo/http_server.config.go (0.0%)</option>
				
				<option value="file2">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/config/mqtt/paho/consumer.config.go (0.0%)</option>
				
				<option value="file3">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/migrations/postgres/postgres.migration.go (0.0%)</option>
				
				<option value="file4">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/models/postgres/climate_data.model.go (83.3%)</option>
				
				<option value="file5">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/models/postgres/iot_devices.model.go (83.3%)</option>
				
				<option value="file6">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo/handlers/get/climate/get_latest_climate_data.handler.go (0.0%)</option>
				
				<option value="file7">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo/handlers/ping/ping.handler.go (0.0%)</option>
				
				<option value="file8">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo/http.server.go (0.0%)</option>
				
				<option value="file9">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo/routes/climate_data/climate_data.routes.go (0.0%)</option>
				
				<option value="file10">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo/routes/echo.routes.go (0.0%)</option>
				
				<option value="file11">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/utils/env.util.go (0.0%)</option>
				
				<option value="file12">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/primary/handlers/mqtt/paho/subscriber.handler.go (0.0%)</option>
				
				<option value="file13">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/mappers/climate_data.mapper.go (100.0%)</option>
				
				<option value="file14">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/mappers/iot_device.mapper.go (100.0%)</option>
				
				<option value="file15">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/repositories/postgres/climate_data/climate_data.repository.go (100.0%)</option>
				
				<option value="file16">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/repositories/postgres/iot_device/iot_device.repository.go (100.0%)</option>
				
				<option value="file17">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/services/postgres/climate_data/get_climate_data.service.go (0.0%)</option>
				
				<option value="file18">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/services/postgres/iot_device/iot_device.service.go (0.0%)</option>
				
				<option value="file19">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/application/usecases/get_climate_data/get_latest_climate_data.usecase.go (0.0%)</option>
				
				<option value="file20">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/application/usecases/save_climate_data/save_climate_data.usecase.go (0.0%)</option>
				
				<option value="file21">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/APIRestPorts.go (0.0%)</option>
				
				<option value="file22">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/Anytime.go (0.0%)</option>
				
				<option value="file23">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/ClimateDataRepositoryPort.go (0.0%)</option>
				
				<option value="file24">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/ClimateDataServicePorts.go (0.0%)</option>
				
				<option value="file25">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/GetLatestClimateDataUseCasePort.go (0.0%)</option>
				
				<option value="file26">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/GormPostgres.go (100.0%)</option>
				
				<option value="file27">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/HandlerMessage.go (0.0%)</option>
				
				<option value="file28">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/IOTDeviceRepositoryPort.go (0.0%)</option>
				
				<option value="file29">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/IOTDeviceServicePort.go (0.0%)</option>
				
				<option value="file30">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/MQTTPorts.go (0.0%)</option>
				
				<option value="file31">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/mocks/SaveClimateDataUseCasePort.go (0.0%)</option>
				
				<option value="file32">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/pkg/gorm/postgres/postgres.pkg.go (0.0%)</option>
				
				<option value="file33">github.com/liwaisi-tech/iot-mqtt-tem-subscriber/pkg/zerolog/zerolog.pkg.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        _ "github.com/joho/godotenv/autoload"

        httpconfig "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/config/http/echo"
        mqttconfig "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/config/mqtt/paho"
        migrations "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/migrations/postgres"
        zerologpkg "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/pkg/zerolog"
)

func main() <span class="cov0" title="0">{
        zerologpkg.LoadLogger()
        migrations.RunMigrations()
        mqttconfig.InitConsumers()
        mqttconfig.RunConsumers()
        httpconfig.NewEchoAPIRestAdapter().RunServer()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "os"

        echoapirest "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo"
        routes "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo/routes"
        ports "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/ports/rest"
)

func NewEchoAPIRestAdapter() ports.APIRestPorts <span class="cov0" title="0">{
        return echoapirest.NewAPIRestServer(
                os.Getenv("API_REST_PORT"),
                os.Getenv("API_REST_BASE_URL"),
                routes.EchoRoutes,
        )
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "context"
        "os"
        "sync"

        mqtthandler "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/primary/handlers/mqtt/paho"
        climatedatarepo "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/repositories/postgres/climate_data"
        iotdevicerepo "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/repositories/postgres/iot_device"
        iotdevicesrv "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/services/postgres/iot_device"
        usecasessave "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/application/usecases/save_climate_data"
        ports "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/ports/events/mqtt"
        gormpkg "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/pkg/gorm/postgres"
)

var (
        mapConsumers map[string]ports.MQTTPorts
        once         sync.Once
)

func InitConsumers() <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                mapConsumers = map[string]ports.MQTTPorts{
                        os.Getenv("MQTT_TOPIC"): getClimateDataConsumer(),
                }
        }</span>)
}

func RunConsumers() <span class="cov0" title="0">{
        for topic, consumer := range mapConsumers </span><span class="cov0" title="0">{
                go consumer.RunConsumer(topic)
        }</span>
}

func getClimateDataConsumer() ports.MQTTPorts <span class="cov0" title="0">{
        gormDB := gormpkg.NewPostgresDBConnection()

        climateDataRepo := climatedatarepo.New(gormDB)
        iotDeviceRepo := iotdevicerepo.New(gormDB)

        iotDeviceService := iotdevicesrv.New(gormDB)

        useCase := usecasessave.New(climateDataRepo, iotDeviceRepo, iotDeviceService)
        return mqtthandler.New(context.Background(), useCase.Execute)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package migrations

import (
        models "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/models/postgres"
        gormpkg "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/pkg/gorm/postgres"
)

func RunMigrations() (err error) <span class="cov0" title="0">{
        gormDB := gormpkg.NewPostgresDBConnection()

        err = gormDB.AutoMigrate(
                &amp;models.IOTDeviceModel{},
                &amp;models.ClimateDataModel{},
        )
        return
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type ClimateDataModel struct {
        ID          *uuid.UUID `gorm:"type:uuid;primaryKey;not null"`
        DeviceID    *uuid.UUID `gorm:"type:uuid;not null"`
        Temperature float64    `gorm:"type:float;not null"`
        Humidity    float64    `gorm:"type:float;not null"`
        gorm.Model

        // Relationships
        Device *IOTDeviceModel `gorm:"foreignKey:DeviceID;references:ID"`
}

func (rm *ClimateDataModel) BeforeCreate(tx *gorm.DB) (err error) <span class="cov8" title="1">{
        newID, err := uuid.NewV7()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rm.ID = &amp;newID
        return</span>
}

func (rm *ClimateDataModel) TableName() string <span class="cov8" title="1">{
        return "climate_data"
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type IOTDeviceModel struct {
        ID         *uuid.UUID `gorm:"type:uuid;primaryKey;not null"`
        MACAddress string     `gorm:"type:varchar(17);not null;unique"`
        gorm.Model
}

func (rm *IOTDeviceModel) BeforeCreate(tx *gorm.DB) (err error) <span class="cov8" title="1">{
        newID, err := uuid.NewV7()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rm.ID = &amp;newID
        return</span>
}

func (rm *IOTDeviceModel) TableName() string <span class="cov8" title="1">{
        return "iot_device"
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "net/http"

        "github.com/labstack/echo/v4"

        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/climate_data"
        ports "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/ports/usecases"
)

func GetClimateDataHandler(
        useCase ports.GetLatestClimateDataUseCasePort,
) func(c echo.Context) (err error) <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                entity, err := useCase.Execute(c.Request().Context())
                if err != nil </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusInternalServerError, map[string]string{
                                "error": err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusOK, mapEntityResponse(entity))</span>
        }
}

func mapEntityResponse(entity *entities.ClimateDataEntity) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "temperature":   entity.Temperature,
                "humidity":      entity.Humidity,
                "last_datetime": entity.CreatedAt.Format("2006-01-02 15:04:05"),
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/labstack/echo/v4"

        global "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/global/constants"
)

func PingHandler() func(c echo.Context) (err error) <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.JSON(http.StatusOK, map[string]string{
                        "response":  "pong",
                        "timestamp": time.Now().Format(global.TimestampWithTimeZoneFormat),
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package entrypoints

import (
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
        "github.com/rs/zerolog/log"

        globalconstants "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/global/constants"
)

type APIRestServer struct {
        echoInstance *echo.Echo
        globalGroup  *echo.Group
        port         string
        routes       func(*echo.Group)
}

func NewAPIRestServer(port, globalPrefix string, routes func(*echo.Group)) *APIRestServer <span class="cov0" title="0">{
        e := echo.New()
        return &amp;APIRestServer{
                echoInstance: e,
                globalGroup:  e.Group(globalPrefix),
                port:         port,
                routes:       routes,
        }
}</span>

func (api *APIRestServer) RunServer() <span class="cov0" title="0">{

        api.echoInstance.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
                CustomTimeFormat: globalconstants.DateAndHourFormat,
                Format:           "[${time_custom}] - method=${method}, uri=${uri}, status=${status}\n",
        }))

        api.routes(api.globalGroup)
        routes := api.echoInstance.Routes()
        for _, route := range routes </span><span class="cov0" title="0">{
                log.Info().Str("method", route.Method).Str("path", route.Path).Msg("echo route")
        }</span>
        <span class="cov0" title="0">api.echoInstance.Logger.Fatal(api.echoInstance.Start(":" + api.port))</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package routes

import (
        "github.com/labstack/echo/v4"
        getclimatedatahandler "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo/handlers/get/climate"
        climatedatasrv "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/services/postgres/climate_data"
        usecasegetlatest "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/application/usecases/get_climate_data"
        ports "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/ports/usecases"
        gormpkg "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/pkg/gorm/postgres"
)

func AddClimateDataEchoRoutes(group *echo.Group) <span class="cov0" title="0">{

        group.GET("climate/latest", getclimatedatahandler.GetClimateDataHandler(getLatestClimateDataUsecase()))
}</span>
func getLatestClimateDataUsecase() ports.GetLatestClimateDataUseCasePort <span class="cov0" title="0">{
        gormDB := gormpkg.NewPostgresDBConnection()
        climateDataSrv := climatedatasrv.New(gormDB)
        return usecasegetlatest.New(climateDataSrv)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package routes

import (
        "github.com/labstack/echo/v4"

        pinghandler "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo/handlers/ping"
        climatedata "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/entrypoints/http/echo/routes/climate_data"
)

func EchoRoutes(group *echo.Group) <span class="cov0" title="0">{

        group.GET("ping", pinghandler.PingHandler())
        climatedata.AddClimateDataEchoRoutes(group)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package utils

import "os"

func IsProduction() bool <span class="cov0" title="0">{
        return os.Getenv("ENV") == "pdn"
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "context"
        "fmt"
        "os"

        mqtt "github.com/eclipse/paho.mqtt.golang"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

type HandlerMessage func(ctx context.Context, eventMessage []byte) (err error)

type SubscriberHandler struct {
        ctx            context.Context
        handlerMessage HandlerMessage
        choke          chan mqtt.Message
}

func New(
        ctx context.Context,
        handlerMessage HandlerMessage,
) *SubscriberHandler <span class="cov0" title="0">{
        return &amp;SubscriberHandler{
                ctx:            ctx,
                handlerMessage: handlerMessage,
        }
}</span>

func (sh *SubscriberHandler) RunConsumer(topic string) <span class="cov0" title="0">{
        qos := byte(0)
        sh.choke = make(chan mqtt.Message)
        clientOptions := getClientOptions()
        clientOptions.SetDefaultPublishHandler(
                func(client mqtt.Client, msg mqtt.Message) </span><span class="cov0" title="0">{
                        sh.choke &lt;- msg
                }</span>,
        )
        <span class="cov0" title="0">client := mqtt.NewClient(clientOptions)
        if token := client.Connect(); token.Wait() &amp;&amp; token.Error() != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(token.Error()).Msg("Error connecting to MQTT Broker")
                panic(token.Error())</span>
        }

        <span class="cov0" title="0">if token := client.Subscribe(topic, qos, nil); token.Wait() &amp;&amp; token.Error() != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(token.Error()).Msg("Error subscribing to MQTT Broker")
                panic(token.Error())</span>
        }
        <span class="cov0" title="0">log.Info().Str("topic", topic).Msg("Subscribed to MQTT Broker")
        for </span><span class="cov0" title="0">{
                incoming := &lt;-sh.choke
                log.Info().Str("topic", "").Msgf("Received message: %v", string(incoming.Payload()))
                err := sh.handlerMessage(sh.ctx, incoming.Payload())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed processing MQTT message")
                        continue</span>
                }
                <span class="cov0" title="0">log.Info().Msg("MQTT message processed successfully")</span>
        }
}

func getClientOptions() (clientOptions *mqtt.ClientOptions) <span class="cov0" title="0">{
        clientOptions = mqtt.NewClientOptions()
        clientOptions.AddBroker(os.Getenv("MQTT_BROKER"))
        clientOptions.SetClientID(fmt.Sprintf("%s-%s", os.Getenv("MQTT_CLIENT_ID"), uuid.New().String()))
        clientOptions.SetUsername(os.Getenv("MQTT_USERNAME"))
        clientOptions.SetPassword(os.Getenv("MQTT_PASSWORD"))
        clientOptions.SetCleanSession(true)
        return
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package mappers

import (
        "github.com/google/uuid"
        models "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/models/postgres"
        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/climate_data"
        "github.com/rs/zerolog/log"
)

func MapClimateDataEntityToModel(entity *entities.ClimateDataEntity) (model *models.ClimateDataModel, err error) <span class="cov8" title="1">{
        if entity == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var id, deviceID uuid.UUID
        if entity.ID != "" </span><span class="cov8" title="1">{
                id, err = uuid.Parse(entity.ID)
                if err != nil </span><span class="cov8" title="1">{
                        log.Error().Err(err).Msg("error parsing uuid from entity.ID")
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if entity.DeviceID != "" </span><span class="cov8" title="1">{
                deviceID, err = uuid.Parse(entity.DeviceID)
                if err != nil </span><span class="cov8" title="1">{
                        log.Error().Err(err).Msg("error parsing uuid from entity.DeviceID")
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">model = &amp;models.ClimateDataModel{
                ID:          &amp;id,
                Temperature: entity.Temperature,
                Humidity:    entity.Humidity,
                DeviceID:    &amp;deviceID,
        }
        return</span>
}

func MapClimateDataModelToEntity(model *models.ClimateDataModel) (entity *entities.ClimateDataEntity) <span class="cov8" title="1">{
        if model == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">entity = &amp;entities.ClimateDataEntity{
                ID:          model.ID.String(),
                Temperature: model.Temperature,
                Humidity:    model.Humidity,
                DeviceID:    model.DeviceID.String(),
                CreatedAt:   model.CreatedAt,
        }
        return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package mappers

import (
        "github.com/google/uuid"
        models "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/models/postgres"
        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/iot_device"
)

func MapIOTDeviceEntityToModel(entity *entities.IOTDeviceEntity) (model *models.IOTDeviceModel, err error) <span class="cov8" title="1">{
        if entity == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var entityID uuid.UUID
        if entity.ID != "" </span><span class="cov8" title="1">{
                entityID, err = uuid.Parse(entity.ID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">model = &amp;models.IOTDeviceModel{
                ID:         &amp;entityID,
                MACAddress: entity.MACAddress,
        }
        return</span>
}

func MapIOTDeviceModelToEntity(model *models.IOTDeviceModel) (entity *entities.IOTDeviceEntity) <span class="cov8" title="1">{
        if model == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var id string
        if model.ID != nil </span><span class="cov8" title="1">{
                id = model.ID.String()
        }</span>
        <span class="cov8" title="1">entity = &amp;entities.IOTDeviceEntity{
                ID:         id,
                MACAddress: model.MACAddress,
        }
        return</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repositories

import (
        "context"

        "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/mappers"
        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/climate_data"
        "gorm.io/gorm"
)

type ClimateDataRepository struct {
        db *gorm.DB
}

func New(db *gorm.DB) *ClimateDataRepository <span class="cov8" title="1">{
        return &amp;ClimateDataRepository{
                db: db,
        }
}</span>

func (cdr *ClimateDataRepository) CreateClimateData(ctx context.Context, entity *entities.ClimateDataEntity) (newID string, err error) <span class="cov8" title="1">{
        model, err := mappers.MapClimateDataEntityToModel(entity)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if err := cdr.db.Create(&amp;model).Error; err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return model.ID.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repositories

import (
        "context"

        "gorm.io/gorm"

        models "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/models/postgres"
        mappers "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/mappers"
        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/iot_device"
)

type IOTDeviceRepository struct {
        gormDB *gorm.DB
}

func New(gormDB *gorm.DB) *IOTDeviceRepository <span class="cov8" title="1">{
        return &amp;IOTDeviceRepository{
                gormDB: gormDB,
        }
}</span>

func (idr *IOTDeviceRepository) CreateIOTDevice(ctx context.Context, entity *entities.IOTDeviceEntity) (newID string, err error) <span class="cov8" title="1">{
        model, err := mappers.MapIOTDeviceEntityToModel(entity)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">response := idr.gormDB.
                Model(&amp;models.IOTDeviceModel{}).
                Create(&amp;model)

        if response.Error != nil </span><span class="cov8" title="1">{
                return "", response.Error
        }</span>
        <span class="cov8" title="1">newID = model.ID.String()
        return</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        models "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/models/postgres"
        "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/mappers"
        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/climate_data"
        "gorm.io/gorm"
)

type ClimateDataService struct {
        db *gorm.DB
}

func New(db *gorm.DB) *ClimateDataService <span class="cov0" title="0">{
        return &amp;ClimateDataService{
                db: db,
        }
}</span>

func (cds *ClimateDataService) GetLatestClimateData() (climateData *entities.ClimateDataEntity, err error) <span class="cov0" title="0">{
        var model *models.ClimateDataModel
        err = cds.db.
                Model(&amp;models.ClimateDataModel{}).
                Order("created_at desc").
                Limit(1).
                Scan(&amp;model).
                Error
        if err != nil &amp;&amp; err != gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">climateData = mappers.MapClimateDataModelToEntity(model)
        return</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "context"

        models "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/database/models/postgres"
        "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/adapters/secondary/mappers"
        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/iot_device"
        "gorm.io/gorm"
)

type IOTDeviceService struct {
        gormDB *gorm.DB
}

func New(gormDB *gorm.DB) *IOTDeviceService <span class="cov0" title="0">{
        return &amp;IOTDeviceService{
                gormDB: gormDB,
        }
}</span>

func (idr *IOTDeviceService) GetIOTDeviceByMACAddress(ctx context.Context, macAddress string) (iotDevice *entities.IOTDeviceEntity, err error) <span class="cov0" title="0">{
        var model *models.IOTDeviceModel
        err = idr.gormDB.
                Model(&amp;models.IOTDeviceModel{}).
                Where("mac_address = ?", macAddress).
                Scan(&amp;model).
                Error
        if err != nil &amp;&amp; err != gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iotDevice = mappers.MapIOTDeviceModelToEntity(model)

        return</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package usecases

import (
        "context"

        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/climate_data"
        climatedataportsrv "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/ports/services/climate"
)

type GetLatestClimateDataUseCase struct {
        climateDataSrv climatedataportsrv.ClimateDataServicePorts
}

func New(
        climateDataSrv climatedataportsrv.ClimateDataServicePorts,
) *GetLatestClimateDataUseCase <span class="cov0" title="0">{
        return &amp;GetLatestClimateDataUseCase{
                climateDataSrv: climateDataSrv,
        }
}</span>

func (uc *GetLatestClimateDataUseCase) Execute(ctx context.Context) (climateData *entities.ClimateDataEntity, err error) <span class="cov0" title="0">{
        return uc.climateDataSrv.GetLatestClimateData()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package usecases

import (
        "context"
        "encoding/json"

        "github.com/rs/zerolog/log"

        eventmsgdtos "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/dtos/events"
        climatedataentities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/climate_data"
        iotdeviceentities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/iot_device"
        climatedataerr "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/errors/climate_data"
        climatedataportrepo "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/ports/repositories/climate_data"
        iotdeviceportrepo "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/ports/repositories/iot_device"
        iotdeviceportsrv "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/ports/services/iot_device"
)

type SaveClimateDataUseCase struct {
        climateDataRepo  climatedataportrepo.ClimateDataRepositoryPort
        iotDeviceRepo    iotdeviceportrepo.IOTDeviceRepositoryPort
        iotDeviceService iotdeviceportsrv.IOTDeviceServicePort
}

func New(
        climateDataRepo climatedataportrepo.ClimateDataRepositoryPort,
        iotDeviceRepo iotdeviceportrepo.IOTDeviceRepositoryPort,
        iotDeviceService iotdeviceportsrv.IOTDeviceServicePort,
) *SaveClimateDataUseCase <span class="cov0" title="0">{
        return &amp;SaveClimateDataUseCase{
                climateDataRepo:  climateDataRepo,
                iotDeviceRepo:    iotDeviceRepo,
                iotDeviceService: iotDeviceService,
        }
}</span>

func (usecase *SaveClimateDataUseCase) Execute(ctx context.Context, eventMessage []byte) (err error) <span class="cov0" title="0">{
        dto, err := usecase.getDTOFromEventMessage(eventMessage)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">climateDataEntity, err := usecase.getEntityFromDTO(dto)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">deviceEntity, err := usecase.getDeviceEntity(ctx, dto.MACAddress)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">climateDataEntity.DeviceID = deviceEntity.ID

        id, err := usecase.climateDataRepo.CreateClimateData(ctx, climateDataEntity)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("failed to create climate data")
                return
        }</span>
        <span class="cov0" title="0">log.Info().Str("id", id).Msg("climate data created")
        return</span>
}

func (usecase *SaveClimateDataUseCase) getDTOFromEventMessage(eventMessage []byte) (
        dto *eventmsgdtos.IOTMessageEventDTO,
        err error,
) <span class="cov0" title="0">{
        err = json.Unmarshal(eventMessage, &amp;dto)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("failed to unmarshal event message")
                return nil, err
        }</span>
        <span class="cov0" title="0">return</span>
}

func (usecase *SaveClimateDataUseCase) getEntityFromDTO(dto *eventmsgdtos.IOTMessageEventDTO) (
        entity *climatedataentities.ClimateDataEntity,
        err error,
) <span class="cov0" title="0">{
        if dto == nil </span><span class="cov0" title="0">{
                return nil, climatedataerr.ErrIOTDeviceInformationNotFound
        }</span>
        <span class="cov0" title="0">entity = &amp;climatedataentities.ClimateDataEntity{
                Temperature: dto.Temperature,
                Humidity:    dto.Humidity,
        }
        return</span>
}

func (usecase *SaveClimateDataUseCase) getDeviceEntity(
        ctx context.Context,
        macAddress string,
) (
        entity *iotdeviceentities.IOTDeviceEntity,
        err error,
) <span class="cov0" title="0">{
        entity, err = usecase.iotDeviceService.GetIOTDeviceByMACAddress(ctx, macAddress)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("failed to get iot device by mac address")
                return nil, err
        }</span>
        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                entity = &amp;iotdeviceentities.IOTDeviceEntity{
                        MACAddress: macAddress,
                }
                id, err := usecase.iotDeviceRepo.CreateIOTDevice(ctx, entity)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("failed to create iot device")
                        return nil, err
                }</span>
                <span class="cov0" title="0">entity.ID = id</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// APIRestPorts is an autogenerated mock type for the APIRestPorts type
type APIRestPorts struct {
        mock.Mock
}

// RunServer provides a mock function with given fields:
func (_m *APIRestPorts) RunServer() <span class="cov0" title="0">{
        _m.Called()
}</span>

// NewAPIRestPorts creates a new instance of APIRestPorts. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAPIRestPorts(t interface {
        mock.TestingT
        Cleanup(func())
}) *APIRestPorts <span class="cov0" title="0">{
        mock := &amp;APIRestPorts{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package mocks

import (
        "database/sql/driver"
        "time"
)

type AnyTime struct{}

func (a AnyTime) Match(v driver.Value) bool <span class="cov0" title="0">{
        _, ok := v.(time.Time)
        return ok
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/climate_data"
        mock "github.com/stretchr/testify/mock"
)

// ClimateDataRepositoryPort is an autogenerated mock type for the ClimateDataRepositoryPort type
type ClimateDataRepositoryPort struct {
        mock.Mock
}

// CreateClimateData provides a mock function with given fields: ctx, entity
func (_m *ClimateDataRepositoryPort) CreateClimateData(ctx context.Context, entity *entities.ClimateDataEntity) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateClimateData")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *entities.ClimateDataEntity) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, entity)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *entities.ClimateDataEntity) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *entities.ClimateDataEntity) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, entity)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewClimateDataRepositoryPort creates a new instance of ClimateDataRepositoryPort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClimateDataRepositoryPort(t interface {
        mock.TestingT
        Cleanup(func())
}) *ClimateDataRepositoryPort <span class="cov0" title="0">{
        mock := &amp;ClimateDataRepositoryPort{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import (
        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/climate_data"
        mock "github.com/stretchr/testify/mock"
)

// ClimateDataServicePorts is an autogenerated mock type for the ClimateDataServicePorts type
type ClimateDataServicePorts struct {
        mock.Mock
}

// GetLatestClimateData provides a mock function with given fields:
func (_m *ClimateDataServicePorts) GetLatestClimateData() (*entities.ClimateDataEntity, error) <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetLatestClimateData")</span>
        }

        <span class="cov0" title="0">var r0 *entities.ClimateDataEntity
        var r1 error
        if rf, ok := ret.Get(0).(func() (*entities.ClimateDataEntity, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func() *entities.ClimateDataEntity); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*entities.ClimateDataEntity)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewClimateDataServicePorts creates a new instance of ClimateDataServicePorts. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClimateDataServicePorts(t interface {
        mock.TestingT
        Cleanup(func())
}) *ClimateDataServicePorts <span class="cov0" title="0">{
        mock := &amp;ClimateDataServicePorts{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/climate_data"
        mock "github.com/stretchr/testify/mock"
)

// GetLatestClimateDataUseCasePort is an autogenerated mock type for the GetLatestClimateDataUseCasePort type
type GetLatestClimateDataUseCasePort struct {
        mock.Mock
}

// Execute provides a mock function with given fields: ctx
func (_m *GetLatestClimateDataUseCasePort) Execute(ctx context.Context) (*entities.ClimateDataEntity, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Execute")</span>
        }

        <span class="cov0" title="0">var r0 *entities.ClimateDataEntity
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (*entities.ClimateDataEntity, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) *entities.ClimateDataEntity); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*entities.ClimateDataEntity)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewGetLatestClimateDataUseCasePort creates a new instance of GetLatestClimateDataUseCasePort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGetLatestClimateDataUseCasePort(t interface {
        mock.TestingT
        Cleanup(func())
}) *GetLatestClimateDataUseCasePort <span class="cov0" title="0">{
        mock := &amp;GetLatestClimateDataUseCasePort{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package mocks

import (
        "testing"

        "github.com/DATA-DOG/go-sqlmock"
        "github.com/stretchr/testify/assert"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

func NewPostgresGormDB(t *testing.T) (*gorm.DB, sqlmock.Sqlmock) <span class="cov8" title="1">{
        mockDB, mock, err := sqlmock.New()
        assert.NoError(t, err)

        gormDB, err := gorm.Open(postgres.New(postgres.Config{
                Conn:                 mockDB,
                PreferSimpleProtocol: true,
        }), &amp;gorm.Config{Logger: logger.Default.LogMode(logger.Silent)})
        assert.NoError(t, err)

        return gormDB, mock
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// HandlerMessage is an autogenerated mock type for the HandlerMessage type
type HandlerMessage struct {
        mock.Mock
}

// Execute provides a mock function with given fields: ctx, eventMessage
func (_m *HandlerMessage) Execute(ctx context.Context, eventMessage []byte) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, eventMessage)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Execute")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, []byte) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, eventMessage)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewHandlerMessage creates a new instance of HandlerMessage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHandlerMessage(t interface {
        mock.TestingT
        Cleanup(func())
}) *HandlerMessage <span class="cov0" title="0">{
        mock := &amp;HandlerMessage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/iot_device"
        mock "github.com/stretchr/testify/mock"
)

// IOTDeviceRepositoryPort is an autogenerated mock type for the IOTDeviceRepositoryPort type
type IOTDeviceRepositoryPort struct {
        mock.Mock
}

// CreateIOTDevice provides a mock function with given fields: ctx, entity
func (_m *IOTDeviceRepositoryPort) CreateIOTDevice(ctx context.Context, entity *entities.IOTDeviceEntity) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateIOTDevice")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *entities.IOTDeviceEntity) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, entity)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *entities.IOTDeviceEntity) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *entities.IOTDeviceEntity) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, entity)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewIOTDeviceRepositoryPort creates a new instance of IOTDeviceRepositoryPort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIOTDeviceRepositoryPort(t interface {
        mock.TestingT
        Cleanup(func())
}) *IOTDeviceRepositoryPort <span class="cov0" title="0">{
        mock := &amp;IOTDeviceRepositoryPort{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entities "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/internal/domain/entities/iot_device"
        mock "github.com/stretchr/testify/mock"
)

// IOTDeviceServicePort is an autogenerated mock type for the IOTDeviceServicePort type
type IOTDeviceServicePort struct {
        mock.Mock
}

// GetIOTDeviceByMACAddress provides a mock function with given fields: ctx, macAddress
func (_m *IOTDeviceServicePort) GetIOTDeviceByMACAddress(ctx context.Context, macAddress string) (*entities.IOTDeviceEntity, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, macAddress)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetIOTDeviceByMACAddress")</span>
        }

        <span class="cov0" title="0">var r0 *entities.IOTDeviceEntity
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*entities.IOTDeviceEntity, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, macAddress)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *entities.IOTDeviceEntity); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, macAddress)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*entities.IOTDeviceEntity)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, macAddress)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewIOTDeviceServicePort creates a new instance of IOTDeviceServicePort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIOTDeviceServicePort(t interface {
        mock.TestingT
        Cleanup(func())
}) *IOTDeviceServicePort <span class="cov0" title="0">{
        mock := &amp;IOTDeviceServicePort{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// MQTTPorts is an autogenerated mock type for the MQTTPorts type
type MQTTPorts struct {
        mock.Mock
}

// RunConsumer provides a mock function with given fields: topic
func (_m *MQTTPorts) RunConsumer(topic string) <span class="cov0" title="0">{
        _m.Called(topic)
}</span>

// NewMQTTPorts creates a new instance of MQTTPorts. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMQTTPorts(t interface {
        mock.TestingT
        Cleanup(func())
}) *MQTTPorts <span class="cov0" title="0">{
        mock := &amp;MQTTPorts{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by mockery v2.42.3. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// SaveClimateDataUseCasePort is an autogenerated mock type for the SaveClimateDataUseCasePort type
type SaveClimateDataUseCasePort struct {
        mock.Mock
}

// Execute provides a mock function with given fields: ctx, eventMessage
func (_m *SaveClimateDataUseCasePort) Execute(ctx context.Context, eventMessage []byte) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, eventMessage)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Execute")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, []byte) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, eventMessage)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewSaveClimateDataUseCasePort creates a new instance of SaveClimateDataUseCasePort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSaveClimateDataUseCasePort(t interface {
        mock.TestingT
        Cleanup(func())
}) *SaveClimateDataUseCasePort <span class="cov0" title="0">{
        mock := &amp;SaveClimateDataUseCasePort{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package postgres

import (
        "fmt"
        "os"
        "strconv"
        "sync"
        "time"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"

        utils "github.com/liwaisi-tech/iot-mqtt-tem-subscriber/infraestructure/utils"
)

var (
        dbInstance *gorm.DB
        once       sync.Once
)

const Format = "%v, %v"

func newDBConnection() (db *gorm.DB, err error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable",
                os.Getenv("PG_DATABASE_HOST"),
                os.Getenv("PG_DATABASE_USER"),
                os.Getenv("PG_DATABASE_PASSWORD"),
                os.Getenv("PG_DATABASE_NAME"),
                os.Getenv("PG_DATABASE_PORT"),
        )
        db, err = gorm.Open(postgres.Open(dsn))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">maxIdleConns, _ := strconv.Atoi(os.Getenv("GORM_MAX_IDLE_CONNS"))
        sqlDB.SetMaxIdleConns(maxIdleConns)
        maxOpenConns, _ := strconv.Atoi(os.Getenv("GORM_MAX_OPEN_CONNS"))
        sqlDB.SetMaxOpenConns(maxOpenConns)
        maxLifeTime, _ := strconv.Atoi(os.Getenv("GORM_MAX_LIFE_TIME"))
        sqlDB.SetConnMaxLifetime(time.Minute * time.Duration(maxLifeTime))
        if !utils.IsProduction() </span><span class="cov0" title="0">{
                db = db.Debug()
        }</span>
        <span class="cov0" title="0">return</span>
}

func NewPostgresDBConnection() *gorm.DB <span class="cov0" title="0">{
        if dbInstance == nil </span><span class="cov0" title="0">{
                once.Do(func() </span><span class="cov0" title="0">{
                        var err error
                        db, err := newDBConnection()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">dbInstance = db</span>
                })
                <span class="cov0" title="0">return dbInstance</span>
        }
        <span class="cov0" title="0">return dbInstance</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package zerolog

import (
        "os"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

func LoadLogger() <span class="cov0" title="0">{
        zerolog.SetGlobalLevel(zerolog.InfoLevel)

        log.Logger = log.Output(zerolog.ConsoleWriter{
                Out: os.Stderr,
        })
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
